# ND-06.009.01 NORD-10/S Functional Description

## I.1 NORD-10/S ARCHITECTURE

### I.1.3 ARITHMETIC, REGISTERS AND CONTROL

#### I.1.3.1 Register Block

The CPU has 16 program levels, each level has the following 8 registers:

- **0 STS**  *Status.* This register holds different status indicators.
- **1 D** This register is an extension of the A register in double precision or floating point operations. It may also be connected to the A register during double length shifts.
- **2 P** Program Counter, address of current instruction. This register is controlled automatically in the normal sequencing or branching mode.  But it is also fully program controlled and its contents may be transferred to or from other registers.
- **3 B** Base register or second index register. In connection with indirect addressing, it causes pre-indexing.
- **4 L** *Link register.* The return address after a subroutine jump is contained in this register.
- **5 A** This is the main register for arithmetical and logical operations together with operands in memory. The register is also used for CPU controlled I/O communication.
- **6 T** Temporary register. In floating point instructions it is used to hold the exponent part.
- **7 X** Index register. In connection with indirect addressing, it causes post-indexing.

### II.3.3 THE ADDRESS ARITHMETIC

#### II.3.3.2 Addressing Structure

Generally, in memory reference instructions, 11 bits are used to specify the address of the desired word(s) in memory. Three address mode bits and an 8-bit signed displacement using 2's complement for negative numbers and sign extension (Excepted from this is the conditional jump, the byte, and the register block instructions).

NORD-10/S uses a relative addressing system, which means that the address is specified relative to the contents of the program counter or relative to the contents of the B and/or X register.

The three addressing mode bits called, `,X`, `I` and `,B` providing eight different addressing modes.

The addressing mode bits have the following meaning:
- The `I` bit specifies indirect addressing
- The `,B` bit specifies address relative to the contents of the B register, pre-indexing. The indexing by B takes place before a possible indirect addressing.
- The `X` bit specifies address relative to the contents of the `X` register post-indexing. The indexing by `X` takes place after a possible indirect addressing.

If all the `,X`, `I` and `,B` bits are zero, the normal relative addressing mode is specified. The effective address is equal to the contents of the program counter plus the displacement (P) + displacement.

The displacement may consist of a number ranging from -128 to +127.
Therefore, this addressing mode gives a dynamic range for directly addressing 128 locations backwards and 127 locations forward.

Note that there is no addition in execution time for relative addressing, pre-indexing, post-indexing or both. Indirect addressing, however, adds one memory cycle to the listed execution times.

## III.2 NORD-10/S INSTRUCTIONS

### III.2.1 MEMORY REFERENCE INSTRUCTIONS
```
┌───────────────────┬───┬───┬───┬─────────────────────┐
│      OP. CODE     │ X │ I │ B │   Displacement (Δ)  │
│ 15 │ 14 13 12 │ 11 10   9 │ 8   7 6 │ 5 4 3 │ 2 1 0 │
└────┴──────────┴───────────┴─────────┴───────┴───────┘
```

#### Store Instructions

| Mnemonic | Opcode  | Description                 | Address Formula  |
|----------|---------|-----------------------------|------------------|
| —        | 000000  | Address relative to P       | EL = P + Δ       |
| ,X       | 002000  | Address relative to X       | EL = X + Δ       |
| I        | 001000  | Indirect address            | EL = (P + Δ)     |
| ,XI      | 003000  | Post-indexing               | EL = (P + Δ) + X |
| ,B       | 000400  | Address relative to B       | EL = B + Δ       |
| ,X,B     | 002400  | Address relative to B and X | EL = B + Δ + X   |
| I,B      | 001400  | Pre-indexing                | EL = (B + Δ)     |
| ,XI,B    | 003400  | Pre- and Post-indexing      | EL = (B + Δ) + X |

Key:
-	P: Program Counter
-	X: Index register
-	B: Base register
-	I: Indirect addressing
-	Δ: Displacement value

#### Store Instructions

| Mnemonic | Opcode  | Description                       | Operation        |
|----------|---------|-----------------------------------|------------------|
| STZ      | 000000  | Store zero                        | (EL): = 0        |
| STA      | 004000  | Store A                           | (EL): = A        |
| STT      | 010000  | Store T                           | (EL): = T        |
| STX      | 014000  | Store X                           | (EL): = X        |
| MIN      | 040000  | Memory increment and skip if zero | (EL): = (EL) + 1 |

#### Load Instructions

| Mnemonic | Opcode  | Description | Operation |
|----------|---------|-------------|-----------|
| LDA      | 044000  | Load A      | A: = (EL) |
| LDT      | 040000  | Load T      | T: = (EL) |
| LDX      | 054000  | Load X      | X: = (EL) |

#### Arithmetical and Logical Instructions

| Mnemonic | Opcode  | Description                                  | Operation     |
|----------|---------|----------------------------------------------|---------------|
| ADD      | 060000  | Add to A (C, O, and Q may be affected)       | A: = A + (EL) |
| SUB      | 064000  | Subtract from A (C, O, and Q may be affected)| A: = A − (EL) |
| AND      | 070000  | Logical AND to A                             | A: = A ∧ (EL) |
| ORA      | 074000  | Logical inclusive OR to A                    | A: = A ∨ (EL) |
| MPY      | 120000  | Multiply integer (O and Q may be affected)   | A: = A · (EL) |

#### Double Word Instructions

```
    ┌──────────────┬──────────────┐
DA  │  A           │  D           │
    └──────────────┴──────────────┘
    ┌──────────────┬──────────────┐
DW  │  EL          │  EL + 1      │
    └──────────────┴──────────────┘
```

| Mnemonic | Opcode  | Description           | Operation     |
|----------|---------|-----------------------|---------------|
| STD      | 020000  | Store double word     | (DW): = AD    |
| LDD      | 024000  | Load double word      | AD: = (DW)    |

#### Floating Instructions

```
    ┌────────┬────────┬────────┐
TAD │    T   │    A   │    D   │
    └────────┴────────┴────────┘
    ┌────────┬────────┬────────┐
FW  │  EL    │ EL + 1 │ EL + 2 │
    └────────┴────────┴────────┘
```

| Mnemonic | Opcode  | Description                                    | Operation           |
|----------|---------|------------------------------------------------|---------------------|
| STF      | 030000  | Store floating accumulator                     | (FW): = TAD         |
| LDF      | 034000  | Load floating accumulator                      | TAD: = (FW)         |
| FAD      | 100000  | Add to floating accum. (C may also be affected)| TAD: = TAD + (FW)   |
| FSB      | 104000  | Subtract from floating accum. (C may be affected)| TAD: = TAD − (FW) |
| FMU      | 110000  | Multiply floating accum. (C may be affected)   | TAD: = TAD * (FW)   |
| FDV      | 114000  | Divide floating accum. (Z and C may be affected)| TAD: = TAD / (FW)  |

#### Byte Instructions

Addressing: `EL = (T) + (X) / 2`

- Least significant bit of X = 1; Right byte
- Least significant bit of X = 0; Left byte

| Mnemonic | Opcode | Description      |
|----------|--------|------------------|
| SBYT     | 142600 | Store right byte |
| LBYT     | 142200 | Load left byte   |

### III.2.2 REGISTER BLOCK INSTRUCTIONS

```
┌─────────────────────────────────┬───────────┬───────┐
│  1    1  0  1    0  1  0   1  0 │   Level   │ 0 0 0 │
│                            1  1 │           │ 0 1 0 │
│ 15 │ 14 13 12 │ 11 10  9 │ 8  7 │ 6 │ 5 4 3 │ 2 1 0 │
└────┴──────────┴──────────┴──────┴───┴───────┴───────┘
```

Adressing: `EL = (X)` on current level

| Mnemonic | Opcode | Description                                | Operation  |
|----------|--------|--------------------------------------------|------------|
| LRB      | 152600 | Load register block P on specified level   | = (EL)     |
|          |        | Load register block X on specified level   | = (EL) + 1 |
|          |        | Load register block T on specified level   | = (EL) + 2 |
|          |        | Load register block A on specified level   | = (EL) + 3 |
|          |        | Load register block D on specified level   | = (EL) + 4 |
|          |        | Load register block L on specified level   | = (EL) + 5 |
|          |        | Load register block STS on specified level | = (EL) + 6 |
|          |        | Load register block B on specified level   | = (EL) + 7 |
| SRB      | 152402 | Store register block                       |            |

Specified Level:

| Octal | Binary   | Description |
|-------|----------|-------------|
| 0     | 000000   | Level 0     |
| 01    | 000010   | Level 1     |
| ...   | ...      | ...         |
| 017   | 000170   | Level 15    |

### III.2.3 FLOATING CONVERSION

```
┌────────────────────┬──────────┬─────────────────────┐
│  1    1  0  1    0 │ Subinstr │    Scaling factor   │
│ 15 │ 14 13 12 │ 11  10  9 │ 8   7 6 │ 5 4 3 │ 2 1 0 │
└────┴──────────┴───────────┴─────────┴───────┴───────┘
```

| Mnemonic | Opcode  | Description                                                    |
|----------|---------|----------------------------------------------------------------|
| NLZ      | 151400  | Convert the number in A to a floating number in FA             |
| DNZ      | 152000  | Convert the floating number in FA to a fixed point number in A |
| NLZ+20   | 151420  | Integer to floating conversion                                 |
| DNZ−20   | 152360  | Floating to integer conversion                                 |

The range of scaling factor is $−128$ to $127$ which gives converting range from $10^{-39}$ to $10^{39}$.

### III.2.4 ARGUMENT INSTRUCTIONS

```
┌────────────────────┬──────────┬─────────────────────┐
│  1    1  1  1    0 │ Function │       Argument      │
│ 15 │ 14 13 12 │ 11  10  9 │ 8   7 6 │ 5 4 3 │ 2 1 0 │
└────┴──────────┴───────────┴─────────┴───────┴───────┘
```

Function:

| Mnemonic | Opcode | Description       | Operation    |
|----------|--------|-------------------|--------------|
| SAA      | 170400 | Set argument to A | A := ARG     |
| AAA      | 172400 | Add argument to A | A := A + ARG |
| SAX      | 171400 | Set argument to X | X := ARG     |
| AAX      | 173400 | Add argument to X | X := X + ARG |
| SAT      | 171000 | Set argument to T | T := ARG     |
| AAT      | 173000 | Add argument to T | T := T + ARG |
| SAB      | 170000 | Set argument to B | B := ARG     |
| AAB      | 172000 | Add argument to B | B := B + ARG |

Argument is a signed number ranging from $-128$ to $127$.

### III.2.5 REGISTER OPERATIONS

```
┌────────────────────┬─────┬───┬───┬───┬───┬───────┬───────┐
│  1    1  0  0    1 │ RAD │ C │ I │CM1│CLD│ Source│  Dest │
│ 15 │ 14 13 12 │ 11    10   9 │ 8   7   6 │ 5 4 3 │ 2 1 0 │
└────┴──────────┴──────────────┴───────────┴───────┴───────┘
```

#### Arithmetic Operations (RAD = 1):

(C, O and Q may be affected by these instructions)

| Mnemonic | Opcode  | Description                         | Operation           |
|----------|---------|-------------------------------------|---------------------|
| RADD     | 146000  | Add source to destination           | (dr) := (dr) + (sr) |
| RSUB     | 146600  | Subtract source from destination    | (dr) := (dr) − (sr) |
| COPY     | 146100  | Register transfer                   | (dr) := (sr)        |
| AD1      | 000400  | Also add one to destination         | (dr) := (dr) + 1    |
| ADC      | 001000  | Also add old carry to destination   | (dr) := (dr) + C    |

#### Logical Operations (RAD = 0)

| Mnemonic | Opcode | Description                        | Operation                  |
|----------|--------|------------------------------------|----------------------------|
| SWAP     | 144000 | Register exchange                  | (sr) := (dr), (dr) := (sr) |
| RAND     | 144400 | Logical AND to destination         | (dr) := (dr) ∧ (sr)        |
| REXO     | 145000 | Logical exclusive OR               | (dr) := (dr) ⊕ (sr)        |
| RORA     | 145400 | Logical inclusive OR               | (dr) := (dr) ∨ (sr)        |
|
| CLD      | 000100 | Clear destination before operation | (dr) := 0                  |
| CM1      | 000200 | Use one’s complement of source     | (sr) := (sr)̅               |

#### Combined instructions

| Mnemonic | Opcode  | Equivalent  | Description            |
|----------|---------|-------------|------------------------|
| EXIT     | 146142  | COPY SL, DP | Return from subroutine |
| RCLR     | 146100  | COPY,       | Register clear         |
| RINC     | 146400  | RADD AD1,   | Register increment     |
| RCDR     | 146200  | RADD CM1,   | Register decrement     |

#### Specify Source Register (sr):

| Mnemonic | Opcode | Description          |
|----------|--------|----------------------|
| SD       | 000010 | D register as source |
| SP       | 000020 | P register as source |
| SB       | 000030 | B register as source |
| SL       | 000040 | L register as source |
| SA       | 000050 | A register as source |
| ST       | 000060 | T register as source |
| SX       | 000070 | X register as source |
| —        | 000000 | Source value = 0     |

#### Specify Destination Register (dr):

| Mnemonic | Opcode | Description               |
|----------|--------|---------------------------|
| DD       | 000001 | D register as destination |
| DP       | 000002 | P register as destination |
| DB       | 000003 | B register as destination |
| DL       | 000004 | L register as destination |
| DA       | 000005 | A register as destination |
| DT       | 000006 | T register as destination |
| DX       | 000007 | X register as destination |

#### Extended Arithmetic Operations

| Mnemonic | Opcode | Description                                                                   | Operation         |
|----------|--------|-------------------------------------------------------------------------------|-------------------|
| RMPY     | 141200 | Multiply source with destination. Result in double accumulator.               | AD := (sr) × (dr) |
| RDIV     | 141600 | Divide double accumulator with source register. Quotient in A, remainder in D | A := AD // (sr)   |

(AD = A<sup>*</sup × (sr) + D)

### III.2.6 BIT INSTRUCTIONS

```
┌────────────────────┬───────────────┬───────────┬───────┐
│  1    1  1  1    1 │    Function   │  Bit no.  │  Dest │
│ 15 │ 14 13 12 │ 11   10  9 │ 8   7   6 │ 5 4 3 │ 2 1 0 │
└────┴──────────┴────────────┴───────────┴───────┴───────┘
```
| Mnemonic | Opcode | Description                                | Operation        |
|----------|--------|--------------------------------------------|------------------|
| BSKP     | 175000 | Skip next location if condition is true    | P := P + 1       |
| BSET     | 174000 | Set specified bit equal to specified cond. |                  |
| BSTA     | 176200 | Store and clear K                          | (B): = K; K := 0 |
| BSTC     | 176000 | Store and complement and set K             | (B): = K̅; K := 1 |
| BLDA     | 176600 | Load K                                     | K := (B)         |
| BLDC     | 176400 | Load bit complement to K                   | K := (B)̅         |
| BANC     | 177000 | Logical AND with bit complement            | K := K ∧ (B)̅     |
| BORC     | 177400 | Logical OR with bit complement             | K := K ∨ (B)̅     |
| BAND     | 177200 | Logical AND to K                           | K := K ∧ (B)     |
| BORA     | 177600 | Logical OR to K                            | K := K ∨ (B)     |

#### Specify Conditions

| Mnemonic | Opcode | Description                     | Operation |
|----------|--------|---------------------------------|-----------|
| ZRO      | 000000 | Specified bit equals zero       | (B): = 0  |
| ONE      | 000200 | Specified bit equals one        | (B): = 1  |
| BAC      | 000600 | Specified bit equals K          | (B): = K  |
| BCM      | 000400 | Complement specified bit        | (B): = (B)̅ |

#### Specify Bit Number

| Decimal | Octal  | Description                           | Operation |
|---------|--------|---------------------------------------|-----------|
| 0       | 000000 | Specifies bit in destination register | B := 0    |
| 010     | 000010 |                                       | B := 1    |
| 020     | 000020 |                                       | B := 2    |
| ...     | ...    |                                       | ...       |
| 0170    | 000170 |                                      | B := 15   |

For destination (`D`) mnemonics, see the previous section — **III.2.5**. 

`D = 0` specifies STS register.

#### Specify Control Flip-Flop

| Mnemonic | Opcode | Specifies               | B Register Mapping |
|----------|--------|-------------------------|--------------------|
| SSTG     | 000010 | Floating rounding       | B := TG            |
| SSK      | 000020 | One bit accumulator     | B := K             |
| SSZ      | 000030 | Floating point overflow | B := Z             |
| SSQ      | 000040 | Dynamic overflow        | B := Q             |
| SSO      | 000040 | Static overflow         | B := O             |
| SSC      | 000060 | Carry                   | B := C             |
| SSM      | 000070 | Multi-shift link        | B := M             |

### III.2.7 SEQUENCING INSTRUCTIONS

#### Unconditional Jump

For instruction word format and effective address, see Section III.2.1.

| Mnemonic | Opcode  | Description             | Operation    |
|----------|---------|-------------------------|--------------|
| JMP      | 124000  | Jump                    | P = EL       |
| JPL      | 134000  | Jump to subroutine      | L = P; P = EL|

#### Conditional Jump

```
┌────────────────────┬───────────┬────────────────────┐
│  1    0  1  1    0 │ Condition │  Displacement (Δ)  │
│ 15 │ 14 13 12 │ 11  10  9 │ 8   7 6 │ 5 4 3 │ 2 1 0 │
└────┴──────────┴───────────┴─────────┴───────┴───────┘
```

| Mnemonic | Opcode  | Description                       | Condition              |
|----------|---------|-----------------------------------|------------------------|
| JAP      | 130000  | Jump if A is positive             | A ≥ 0; P = P ± Δ       |
| JAN      | 130400  | Jump if A is negative             | A < 0                  |
| JAZ      | 131000  | Jump if A is zero                 | A = 0                  |
| JAF      | 131400  | Jump if A is non-zero             | A ≠ 0                  |
| JXN      | 133400  | Jump if X is negative             | X < 0                  |
| JPC      | 132000  | Increment X and jump if positive  | X = X + 1; P = P + Δ if X ≥ 0 |
| JNC      | 132400  | Increment X and jump if negative  | X = X + 1; P = P + Δ if X < 0  |

#### Skip Instructions

```
┌────────────────────┬───────────┬───┬───────────┬───────┐
│  1    1  0  0    0 │ Condition │   │   Source  │  Dest │
│ 15 │ 14 13 12 │ 11  10  9 │ 8    7   6 │ 5 4 3 │ 2 1 0 │
└────┴──────────┴───────────┴────────────┴───────┴───────┘
```

| Mnemonic | Opcode  | Description                                    | Operation  |
|----------|---------|------------------------------------------------|------------|
| SKP      | 140000  | Skip next location if specified condition true | P = P + 1  |

#### Specified Condition:

| Mnemonic | Opcode  | Description                     |
|----------|---------|---------------------------------|
| EQL      | 000000  | Equal to                        |
| UEQ      | 002000  | Unequal to                      |
| GRE      | 001000  | Signed greater or equal to      |
| LST      | 003000  | Signed less than                |
| MLST     | 003400  | Magnitude less than             |
| MGRE     | 001400  | Magnitude greater or equal to   |
| IF       | 000000  | May be used freely to obtain    |
| O        | 000000  | Easy readability                |

For Source and Destination mnemonics, see Section III.2.5.

### III.2.8 SHIFT INSTRUCTIONS

```
┌────────────────────┬───────┬───────┬───┬───────────────┐
│  1    1  0  1    1 │  LIN  │  SAD  │   │ Shift counter │
│                    │ZIN│ROT│SHA│SHD│   │               │
│ 15 │ 14 13 12 │ 11   10  9 │ 8   7   6 │ 5 4 3 │ 2 1 0 │
└────┴──────────┴────────────┴───────────┴───────┴───────┘
```

| Mnemonic | Opcode | Description                                                               |
|----------|--------|---------------------------------------------------------------------------|
| SHT      | 154000 | Shift T register                                                          |
| SHD      | 154200 | Shift D register                                                          |
| SHA      | 155500 | Shift A register                                                          |
| SAD      | 154600 | Shift A and D register connected                                          |
|          | 000000 | Arithmetic shift. Right: bit 15 extended; Left: zeros shifted from right. |
| ROT      | 001000 | Rotational shift. Most and least significant bits are connected.          |
| ZIN      | 002000 | Zero end input                                                            |
| LIN      | 003000 | Link end input. Last vacated bit fed to M after every shift instruction.  |
| SHR      |        | Shift right; gives negative shift counter.                                |

### III.2.9 TRANSFER INSTRUCTIONS

#### Level Independent Instructions

```
┌────────────────────┬──────────────┬───────┬───────┐
│  1    1  0  1    0 │   Subinstr   │       │   R   │
│ 15 │ 14 13 12 │ 11   10 9 │ 8 7 6 │ 5 4 3 │ 2 1 0 │
└────┴──────────┴───────────┴───────┴───────┴───────┘
```

| Mnemonic | Opcode  | Description                      |
|----------|---------|----------------------------------|
| TRA      | 150000  | Transfer specified register to A |

**Specified Register R:**

| Mnemonic | Value | Description                        |
|----------|-------|------------------------------------|
| STS      | 1     | Status register                    |
| OPR      | 2     | Operator’s panel switch register   |
| PSR      | 3     | Paging status register             |
| PVL      | 4     | Previous level code register       |
| IIC      | 5     | Internal interrupt code register   |
| PID      | 6     | Priority interrupt detect register |
| PIE      | 7     | Priority enable detect register    |
| ALD      | 12    | Automatic Load descriptor          |
| PES      | 13    | Parity error status register       |
| PEA      | 15    | Parity error address register      |

| Mnemonic | Opcode  | Description               |
|----------|---------|---------------------------|
| TRR      | 150100  | Transfer A to register R  |